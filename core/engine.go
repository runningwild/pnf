package core

import (
  "fmt"
)

type EngineId int64
type StateFrame int

// EventBundles contain all Events that were generated by all Engines on a
// single frame.
type EventBundles map[EngineId][]Event

func (eb EventBundles) Absorb(eb2 EventBundles) {
  for k, v := range eb2 {
    if _, ok := eb[k]; ok {
      panic("EngineId collision")
    }
    eb[k] = v
  }
}

// TODO: frame should be used to 'randomize' the order the bundles are
// processed.
func (ev EventBundles) Each(frame StateFrame, f func(EngineId, []Event)) {
  max := EngineId(-1)
  max_max := EngineId(-1)
  for i := 0; i < len(ev); i++ {
    for k := range ev {
      if k > max && (k < max_max || max_max == -1) {
        max = k
      }
    }
    max_max = max
    f(max, ev[max])
  }
}

type EngineParams struct {
  delay_ms   int
  frame_ms   int
  max_frames int
}
type Engine struct {
  id      EngineId
  network Network

  params EngineParams
  states GameWindow
  events EventsWindow
  ticker Ticker

  local_events      []Event
  local_events_chan chan Event
}

func NewEngine(network Network) *Engine {
  return &Engine{
    id:                EngineId(RandomId()),
    network:           network,
    ticker:            NewFakeTicker(),
    local_events_chan: make(chan Event, 10),
  }
}

func (e *Engine) StartNewGame(params EngineParams, game Game) {
  e.params = params
  e.states.Set(0, game)
}

// This is the routine that handles all communication
// On each tick we advance the game state
// receives events from localhost
// receives events from the network
func (e *Engine) routine() {
  e.ticker.Start(e.params.frame_ms)
  var frame StateFrame = 0
  for {
    select {

    // Every time we get a ping from the ticker it's time to advance the game
    // state.  If we cannot we'll need to pause and wait for other engines or
    // drop them entirely.
    case <-e.ticker.Chan():
      // bundle up our local events and send them along the network
      bundle := make(EventBundles)
      bundle[e.id] = e.local_events
      e.local_events = nil
      fmt.Printf("%v\n", bundle)
      frame++

    // If the local user has applied some events we need to grab them and them
    // to the appropriate state, and send them across the network.
    case event := <-e.local_events_chan:
      e.local_events = append(e.local_events, event)
    }
  }
}

// Queues the event to be applied on a future game state that is at least
// Delay frames in the future.
func (e *Engine) ApplyEvent(event Event) {
  e.local_events_chan <- event
}

func (e *Engine) GetState(timestep int, game *Game) {}
