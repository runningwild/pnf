package core

import (
  "bytes"
  "encoding/gob"
  "fmt"
)

// FirstX happens once, potentially before any events arrive
// X can happen multiple times, whenever anything changes
// FinalX only happens after all events have arrived

type Event interface {
  // Cannot modify the Game
  ApplyFirst(interface{})

  // Can modify the game
  Apply(interface{})
  ApplyFinal(interface{})
}

type Game interface {
  ThinkFirst()
  Think()
  ThinkFinal()

  Copy() interface{}
  OverwriteWith(game interface{})
}

type AllEvents struct {
  Game   []Event
  Engine []EngineEvent
}

func (ae *AllEvents) GobEncode() ([]byte, error) {
  buf := bytes.NewBuffer(nil)
  enc := gob.NewEncoder(buf)
  err := enc.Encode(uint32(len(ae.Game)))
  if err != nil {
    return nil, err
  }
  for i := range ae.Game {
    err = enc.Encode(&ae.Game[i])
    if err != nil {
      return nil, err
    }
  }
  err = enc.Encode(uint32(len(ae.Engine)))
  if err != nil {
    return nil, err
  }
  for i := range ae.Engine {
    err = enc.Encode(&ae.Engine[i])
    if err != nil {
      return nil, err
    }
  }
  return buf.Bytes(), nil
}

func (ae *AllEvents) GobDecode(data []byte) error {
  dec := gob.NewDecoder(bytes.NewBuffer(data))
  var length uint32

  err := dec.Decode(&length)
  if err != nil {
    return err
  }
  ae.Game = make([]Event, int(length))
  for i := range ae.Game {
    var event Event
    err = dec.Decode(&event)
    if err != nil {
      return err
    }
    ae.Game[i] = event
  }

  err = dec.Decode(&length)
  if err != nil {
    return err
  }
  ae.Engine = make([]EngineEvent, int(length))
  for i := range ae.Engine {
    var event EngineEvent
    err = dec.Decode(&event)
    if err != nil {
      return err
    }
    ae.Engine[i] = event
  }

  return nil
}

// An EventBundle contains all (Engine)?Events that were generated by all
// Engines on a single StateFrame.  
type EventBundle map[EngineId]AllEvents

// Convenient wrapper that includes the Frame that the EventBundle belongs to,
// often the frame is implicit, but when we send it over the wire we want to
// include it with the bundle.
type FrameBundle struct {
  Frame  StateFrame
  Bundle EventBundle
}

func (fb EventBundle) AbsorbEventBundle(fb2 EventBundle) {
  for k, v := range fb2 {
    if _, ok := fb[k]; ok {
      // TODO: Maybe shouldn't panic?  But what should happen, at least need
      // to report the error, maybe if the events are not identical then we
      // can drop the engine.
      panic(fmt.Sprintf("EngineId collision: %d", k))
    }
    fb[k] = v
  }
}

// TODO: frame should be used to 'randomize' the order the bundles are
// processed, but only for GameEvents, not EngineEvents.
func (fb EventBundle) Each(frame StateFrame, f func(EngineId, []Event)) {
  fb.each(frame, func(id EngineId, all AllEvents) {
    f(id, all.Game)
  })
}

func (fb EventBundle) EachEngine(frame StateFrame, f func(EngineId, []EngineEvent)) {
  fb.each(frame, func(id EngineId, all AllEvents) {
    f(id, all.Engine)
  })
}

func (fb EventBundle) each(frame StateFrame, f func(EngineId, AllEvents)) {
  max := EngineId(-1)
  for i := 0; i < len(fb); i++ {
    cur := EngineId(-1)
    for k := range fb {
      if k > max && (k < cur || cur == -1) {
        cur = k
      }
    }
    max = cur
    f(max, fb[cur])
  }
}

// Engine needs to be able to host, join, and communicate events
// There should be a network manager interface that it uses

type player struct {
  x, y int
}
type myGame struct {
  players []player
}
