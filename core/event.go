package core

import (
  "fmt"
)

// FirstX happens once, potentially before any events arrive
// X can happen multiple times, whenever anything changes
// FinalX only happens after all events have arrived

type Event interface {
  // Cannot modify the Game
  ApplyFirst(interface{})

  // Can modify the game
  Apply(interface{})
  ApplyFinal(interface{})
}

type Game interface {
  ThinkFirst()
  Think()
  ThinkFinal()

  Copy() interface{}
  OverwriteWith(game interface{})
}

type AllEvents struct {
  Game   []Event
  Engine []EngineEvent
}

// An EventBundle contains all (Engine)?Events that were generated by all
// Engines on a single StateFrame.  
type EventBundle map[EngineId]AllEvents

// Convenient wrapper that includes the Frame that the EventBundle belongs to,
// often the frame is implicit, but when we send it over the wire we want to
// include it with the bundle.
type FrameBundle struct {
  Frame  StateFrame
  Bundle EventBundle
}

func (fb EventBundle) AbsorbEventBundle(fb2 EventBundle) {
  for k, v := range fb2 {
    if _, ok := fb[k]; ok {
      // TODO: Maybe shouldn't panic?  But what should happen, at least need
      // to report the error, maybe if the events are not identical then we
      // can drop the engine.
      panic(fmt.Sprintf("EngineId collision: %d", k))
    }
    fb[k] = v
  }
}

// TODO: frame should be used to 'randomize' the order the bundles are
// processed, but only for GameEvents, not EngineEvents.
func (fb EventBundle) Each(frame StateFrame, f func(EngineId, []Event)) {
  fb.each(frame, func(id EngineId, all AllEvents) {
    f(id, all.Game)
  })
}

func (fb EventBundle) EachEngine(frame StateFrame, f func(EngineId, []EngineEvent)) {
  fb.each(frame, func(id EngineId, all AllEvents) {
    f(id, all.Engine)
  })
}

func (fb EventBundle) each(frame StateFrame, f func(EngineId, AllEvents)) {
  max := EngineId(-1)
  for i := 0; i < len(fb); i++ {
    cur := EngineId(-1)
    for k := range fb {
      if k > max && (k < cur || cur == -1) {
        cur = k
      }
    }
    max = cur
    f(max, fb[cur])
  }
}

// Engine needs to be able to host, join, and communicate events
// There should be a network manager interface that it uses

type player struct {
  x, y int
}
type myGame struct {
  players []player
}
