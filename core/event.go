package core

// FastX happens once, potentially before any events arrive
// X can happen multiple times, whenever anything changes
// FinalX only happens after all events have arrived

type Event interface {
  // Cannot modify the Game
  ApplyFast(Game)

  // Can modify the game
  Apply(Game)
  ApplyFinal(Game)
}

// An EngineBundle contains all Events that were generated by a single Engine
// on a signle StateFrame.
type EngineBundle struct {
  Frame  StateFrame
  Events []Event
}

// A FrameBundle contains all Events that were generated by all Engines on a
// single StateFrame.  
type FrameBundle map[EngineId][]Event

func (fb FrameBundle) AbsorbFrameBundle(fb2 FrameBundle) {
  for k, v := range fb2 {
    if _, ok := fb[k]; ok {
      // TODO: Maybe shouldn't panic?  But what should happen, at least need
      // to report the error, maybe if the events are not identical then we
      // can drop the engine.
      panic("EngineId collision")
    }
    fb[k] = v
  }
}

func (fb FrameBundle) AbsorbEngineBundle(eb EngineBundle, id EngineId) {
  if _, ok := fb[id]; ok {
    panic("EngineId collision")
  }
  fb[id] = eb.Events
}

// TODO: frame should be used to 'randomize' the order the bundles are
// processed.
func (fb FrameBundle) Each(frame StateFrame, f func(EngineId, []Event)) {
  max := EngineId(-1)
  max_max := EngineId(-1)
  for i := 0; i < len(fb); i++ {
    for k := range fb {
      if k > max && (k < max_max || max_max == -1) {
        max = k
      }
    }
    max_max = max
    f(max, fb[max])
  }
}

type Game interface {
  ThinkFast()
  Think()
  ThinkFinal()
}

// Engine needs to be able to host, join, and communicate events
// There should be a network manager interface that it uses

type player struct {
  x, y int
}
type myGame struct {
  players []player
}
