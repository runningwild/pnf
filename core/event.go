package core

// FastX happens once, potentially before any events arrive
// X can happen multiple times, whenever anything changes
// FinalX only happens after all events have arrived

type Event interface {
  // Cannot modify the Game
  ApplyFast(Game)

  // Can modify the game
  Apply(Game)
  ApplyFinal(Game)
}

// A EventBundle contains all Events that were generated by all Engines on a
// single StateFrame.  
type EventBundle map[EngineId][]Event

// Convenient wrapper that includes the Frame that the EventBundle belongs to,
// often the frame is implicit, but when we send it over the wire we want to
// include it with the bundle.
type FrameBundle struct {
  Frame  StateFrame
  Bundle EventBundle
}

func (fb EventBundle) AbsorbEventBundle(fb2 EventBundle) {
  for k, v := range fb2 {
    if _, ok := fb[k]; ok {
      // TODO: Maybe shouldn't panic?  But what should happen, at least need
      // to report the error, maybe if the events are not identical then we
      // can drop the engine.
      panic("EngineId collision")
    }
    fb[k] = v
  }
}

// TODO: frame should be used to 'randomize' the order the bundles are
// processed.
func (fb EventBundle) Each(frame StateFrame, f func(EngineId, []Event)) {
  max := EngineId(-1)
  max_max := EngineId(-1)
  for i := 0; i < len(fb); i++ {
    for k := range fb {
      if k > max && (k < max_max || max_max == -1) {
        max = k
      }
    }
    max_max = max
    f(max, fb[max])
  }
}

type Game interface {
  ThinkFast()
  Think()
  ThinkFinal()
  Copy() Game
}

// Engine needs to be able to host, join, and communicate events
// There should be a network manager interface that it uses

type player struct {
  x, y int
}
type myGame struct {
  players []player
}
